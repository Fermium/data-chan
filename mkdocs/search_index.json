{
    "docs": [
        {
            "location": "/", 
            "text": "Data-Chan\n\n\nData-chan is either a protocol and a collection of subroutines to use the protocol.\n\n\nData-chan is used to send physics measures from a generic device\nto the PC using native USB, \nNOT AN UGLY SERIAL-\nUSB IC!\n\n\nDue to the diversity of electronics devices and needs the protocol is designed to be:\n\n\n * simple and minimal\n * fast\n * costomizable\n\n\n\nAtmel AVR\n\n\nOn this repository you can find the device client program for the atmega32u4 and other AVR microcontrollers.\n\n\nHave you prepared your arduino nano pro?\n\n\nMeasures and Commands\n\n\nReceiving measures from a generic USB device is the main goal a data-chan.\n\n\nWe all know that physics devices needs command and configuration to properly operate,\nto fulfill this need data-chan can send two types of commands to the target device:\n\n\n * protocol-specific commands\n * free commands", 
            "title": "Home"
        }, 
        {
            "location": "/#data-chan", 
            "text": "Data-chan is either a protocol and a collection of subroutines to use the protocol.  Data-chan is used to send physics measures from a generic device\nto the PC using native USB,  NOT AN UGLY SERIAL- USB IC!  Due to the diversity of electronics devices and needs the protocol is designed to be:   * simple and minimal\n * fast\n * costomizable", 
            "title": "Data-Chan"
        }, 
        {
            "location": "/#atmel-avr", 
            "text": "On this repository you can find the device client program for the atmega32u4 and other AVR microcontrollers.  Have you prepared your arduino nano pro?", 
            "title": "Atmel AVR"
        }, 
        {
            "location": "/#measures-and-commands", 
            "text": "Receiving measures from a generic USB device is the main goal a data-chan.  We all know that physics devices needs command and configuration to properly operate,\nto fulfill this need data-chan can send two types of commands to the target device:   * protocol-specific commands\n * free commands", 
            "title": "Measures and Commands"
        }, 
        {
            "location": "/build/", 
            "text": "Build\n\n\nThe entire project can be compiled with the \"make all\" command, even on windows, but it requires a lot of software!\n\n\nEnvironment\n\n\nOn a generic system you will need at least:\n\n\nmake\n    \ngcc-avr\n\n    \navr-libc\n\n    \ngcc\n\n    \ng++\n\n    \nlibusb-1.0-0-dev\n\n    \nlibpthread-stubs0-dev (pre-installed on most systems)\n\n\n\n\nIf you're using windows you will \nalso\n need to install:\n\n\n    \nmsys 1.0\n\n    \ntdm-gcc\n\n    \ngrep for windows\n\n\n\n\nEither if you are using Linux, Mac OSX or Windows, if you plan to use the Atmega332U4 or any other\nAVR microcontroller you have to install avrdude and buy an usbasp device, because the bootloader will be\nunable to operate again once the first write!", 
            "title": "Building"
        }, 
        {
            "location": "/build/#build", 
            "text": "The entire project can be compiled with the \"make all\" command, even on windows, but it requires a lot of software!", 
            "title": "Build"
        }, 
        {
            "location": "/build/#environment", 
            "text": "On a generic system you will need at least: \nmake\n     gcc-avr \n     avr-libc \n     gcc \n     g++ \n     libusb-1.0-0-dev \n     libpthread-stubs0-dev (pre-installed on most systems)   If you're using windows you will  also  need to install: \n     msys 1.0 \n     tdm-gcc \n     grep for windows   Either if you are using Linux, Mac OSX or Windows, if you plan to use the Atmega332U4 or any other\nAVR microcontroller you have to install avrdude and buy an usbasp device, because the bootloader will be\nunable to operate again once the first write!", 
            "title": "Environment"
        }, 
        {
            "location": "/protocol/", 
            "text": "Protocol\n\n\nThe protocol can be customized starting from the very USB basics.\n\n\nThe protocol minimum entity is a packet.\n\n\nThe protocol makes \nHUGE\n usage of the \nGENERIC_REPORT_SIZE\n macro,\nthat macro defines the number of bytes in each USB packet.\n\n\nThe data-chan protocol uses \nlittle-endian\n then serializing data larger than one byte.\n\n\nPackets Structure\n\n\nBoth IN and OUT packets are formed this way:\n\n\n\n    \n\n        \nbyte\n\n        \nfirst\n\n        \nfollowing\n\n        \nlast\n\n    \n\n    \n\n        \ndesc\n\n        \ntype\n\n        \ndata\n\n        \nCRC-8\n\n    \n\n\n\n\n\nThe first byte contains the packet type: how data is used depends on the very first byte.\n\n\nEach packet ends with the last byte used for the CRC code (standard 8 bits).\n\n\nFrom the host perspective there are two types of packets IN packets and OUT packets.\n\n\nIN packets\n\n\nAn incoming packet can be flagged as either one of these types:\n\n\n    \n00h =\n NONE\n\n    \n01h =\n CMD_RESPONSE\n\n    \n03h =\n MEASURE\n\n\n\n\nWhen the packets is flagged as NONE it must be ignored.\n\n\nBy default every packet will be flagged as NONE, thus avoiding sending data to the Operating System,\nwhich can't decode packets.\n\n\nWhen the device is active every type of packet will be used.\n\n\nA MEASURE description can be found \nhere\n, whereas a CMD_RESPONSE description can be read \nhere\n.", 
            "title": "Protocol"
        }, 
        {
            "location": "/protocol/#protocol", 
            "text": "The protocol can be customized starting from the very USB basics.  The protocol minimum entity is a packet.  The protocol makes  HUGE  usage of the  GENERIC_REPORT_SIZE  macro,\nthat macro defines the number of bytes in each USB packet.  The data-chan protocol uses  little-endian  then serializing data larger than one byte.", 
            "title": "Protocol"
        }, 
        {
            "location": "/protocol/#packets-structure", 
            "text": "Both IN and OUT packets are formed this way:  \n     \n         byte \n         first \n         following \n         last \n     \n     \n         desc \n         type \n         data \n         CRC-8 \n       The first byte contains the packet type: how data is used depends on the very first byte.  Each packet ends with the last byte used for the CRC code (standard 8 bits).  From the host perspective there are two types of packets IN packets and OUT packets.", 
            "title": "Packets Structure"
        }, 
        {
            "location": "/protocol/#in-packets", 
            "text": "An incoming packet can be flagged as either one of these types: \n     00h =  NONE \n     01h =  CMD_RESPONSE \n     03h =  MEASURE   When the packets is flagged as NONE it must be ignored.  By default every packet will be flagged as NONE, thus avoiding sending data to the Operating System,\nwhich can't decode packets.  When the device is active every type of packet will be used.  A MEASURE description can be found  here , whereas a CMD_RESPONSE description can be read  here .", 
            "title": "IN packets"
        }, 
        {
            "location": "/IN_packets/Measure/", 
            "text": "Measure\n\n\nA MEASURE packet has the data field formed this way:\n\n\n\n    \n\n        \nbytes\n\n        \n0\n\n        \n1\n\n        \n2 to 6\n\n        \n7\n\n        \n8 to 12\n\n        \n13 to 14\n\n    \n\n    \n\n        \ntype (8bits)\n\n        \nbyte (8bits)\n\n        \nbyte (8bits)\n\n        \nfloat (32bits)\n\n        \nbyte (8bits)\n\n        \nbig int (32bits)\n\n        \nsmall int (16bits)\n\n    \n\n    \n\n        \ndescr\n\n        \ntype\n\n        \nchannel\n\n        \nvalue\n\n        \nmu\n\n        \ntimestamp\n\n        \nmillis\n\n    \n\n\n\n\n\nAllowed measure types are:\n\n\n    \n00h =\n NONREALTIME\n\n    \n01h =\n OFFSET_REALTIME\n\n    \n02h =\n REALTIME\n\n    \n03h =\n PROGRESSIVE\n\n\n\n\nType\n\n\nIn a NONREALTIME measure time and millis fields are unused, the host will replace their values\nwith the timestamp and millis upon receipt.\n\n\nIn a OFFSET_REALTIME measure time and millis both refers to the moment of measures beginning.\n\n\nIn a REALTIME measure time and millis contains the correct values.\n\n\nIn a PROGRESSIVE measure millis:time contains a progressive number used to indexing the measure.\n\n\nChannel\n\n\nThe channel field is used to identify the channel that has generated the measure.\n\n\nThe channel field starts from 1, this means that an instrument can have 255 possible channels:\nfrom 1 to 255.\n\n\nUnit of Measurement\n\n\nThe Unit of Measurement field is a byte that reveils the used unit of measurement, according to the following list:\n\n\n    \n0 =\n metre\n\n    \n1 =\n ampere\n\n    \n2 =\n volt\n\n    \n3 =\n coulomb\n\n    \n4 =\n watt\n\n    \n5 =\n kilogram\n\n    \n6 =\n kelvin\n\n    \n7 =\n candela\n\n    \n8 =\n mole\n\n    \n9 =\n hertz\n\n    \n10 =\n radian\n\n    \n11 =\n steradian\n\n    \n12 =\n newton\n\n    \n13 =\n pascal\n\n    \n14 =\n joule\n\n    \n15 =\n farad\n\n    \n16 =\n ohm\n\n    \n17 =\n siemens\n\n    \n18 =\n weber\n\n    \n19 =\n tesla\n\n    \n20 =\n henry\n\n    \n21 =\n lumen\n\n    \n22 =\n lux\n\n    \n23 =\n becquerel\n\n    \n24 =\n gray\n\n    \n25 =\n sievert\n\n    \n26 =\n katal\n\n\n\n\nThe last five units codes (251, 252, 253, 254, 255) are application-reserved and how they are used depends on the device vendor.", 
            "title": "Measure"
        }, 
        {
            "location": "/IN_packets/Measure/#measure", 
            "text": "A MEASURE packet has the data field formed this way:  \n     \n         bytes \n         0 \n         1 \n         2 to 6 \n         7 \n         8 to 12 \n         13 to 14 \n     \n     \n         type (8bits) \n         byte (8bits) \n         byte (8bits) \n         float (32bits) \n         byte (8bits) \n         big int (32bits) \n         small int (16bits) \n     \n     \n         descr \n         type \n         channel \n         value \n         mu \n         timestamp \n         millis \n       Allowed measure types are: \n     00h =  NONREALTIME \n     01h =  OFFSET_REALTIME \n     02h =  REALTIME \n     03h =  PROGRESSIVE", 
            "title": "Measure"
        }, 
        {
            "location": "/IN_packets/Measure/#type", 
            "text": "In a NONREALTIME measure time and millis fields are unused, the host will replace their values\nwith the timestamp and millis upon receipt.  In a OFFSET_REALTIME measure time and millis both refers to the moment of measures beginning.  In a REALTIME measure time and millis contains the correct values.  In a PROGRESSIVE measure millis:time contains a progressive number used to indexing the measure.", 
            "title": "Type"
        }, 
        {
            "location": "/IN_packets/Measure/#channel", 
            "text": "The channel field is used to identify the channel that has generated the measure.  The channel field starts from 1, this means that an instrument can have 255 possible channels:\nfrom 1 to 255.", 
            "title": "Channel"
        }, 
        {
            "location": "/IN_packets/Measure/#unit-of-measurement", 
            "text": "The Unit of Measurement field is a byte that reveils the used unit of measurement, according to the following list: \n     0 =  metre \n     1 =  ampere \n     2 =  volt \n     3 =  coulomb \n     4 =  watt \n     5 =  kilogram \n     6 =  kelvin \n     7 =  candela \n     8 =  mole \n     9 =  hertz \n     10 =  radian \n     11 =  steradian \n     12 =  newton \n     13 =  pascal \n     14 =  joule \n     15 =  farad \n     16 =  ohm \n     17 =  siemens \n     18 =  weber \n     19 =  tesla \n     20 =  henry \n     21 =  lumen \n     22 =  lux \n     23 =  becquerel \n     24 =  gray \n     25 =  sievert \n     26 =  katal   The last five units codes (251, 252, 253, 254, 255) are application-reserved and how they are used depends on the device vendor.", 
            "title": "Unit of Measurement"
        }
    ]
}